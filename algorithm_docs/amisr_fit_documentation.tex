%% amisr_fit_documentation.tex

\documentclass[12pt,letterpaper]{article}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\usepackage{amsmath}
\usepackage{natbib}
\usepackage{hyperref}

\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\plaintext}[1]{\texttt{#1}}
\newcommand{\parder}[2]{\frac{\partial{#1}}{\partial{#2}}}
\newcommand{\pardder}[2]{\frac{\partial^2{#1}}{\partial{#2}^2}}

\title{Documentation for the Method used in \plaintext{amisr\_fit.py}}
\author{Leslie J Lamarche}
\date{\today}

\begin{document}

\maketitle

\section{Objective}
  To create a 3D analytical model of any parameter within the FoV of an AMISR through harmonic interpolation.

\section{Motivation}
  The Advanced Modular Incoherent Scatter Radars (AMISR) utilize electronic beam steering to image volumes of the ionosphere.  However, the availability of measurements within the radar FoV is still constrained by the location of the beams for any given mode, e.g., the radar beams are still discrete and you can't measure between beams.  This is an attempt to get around this problem by creating an analytic function that describes a given radar measurement anywhere within the radar field of view (FoV).  In addition to creating an easy way to interpolate between beam measurements (because measurements are not on a grid, traditional interpolation in non-trivial), the function is analytic and therefore differentiable everywhere, allowing 3D gradient vectors to be calculated.

\section{Approach}
  A truncated expansion of 3D linear basis functions are used to model AMISR parameters at all points within the FoV.  The coefficients to this expansion are found with a regularized least-squares fit to the data.  Interpolated densities or gradients can be found by reloading the fitted coefficients and plugging coordinates into the analytic expression.  Details of the fitting process are discussed in section ...

\section{Implementation}
  This code was written in Python 2.7.13.  It requires the following packages installed:
  \begin{itemize}
    \item numpy 1.12.1
    \item scipy 0.19.0
    \item datetime 4.3
    \item tables 3.3.0
    \item matplotlib 2.0.2
  \end{itemize}
  Note: Version numbers given refer to the version of a package code was developed using.  Program SHOULD run with other versions, but this has not been tested.


\section{Model}
  The mathematical model used is a 3D function of \(z\), \(\theta\), and \(\phi\).  It is composed of a truncated expansion of linear 3D basis functions, \(B_n(z,\theta,\phi)\).  The coordinates \(z\), \(\theta\), and \(\phi\) will be expressed as a single vector, \(\vec{r} = (z,\theta,\phi)\) for brevity.  The spatial resolution of the model depends on the total number of basis function, \(N\).  As \(N\) increases, smaller features will be resolved, but the computation time also increases.
  \[f(z,\theta,\phi) = \sum_{n=0}^N c_n B_n(\vec{r})\]
  This can be expressed in matrix notation to represent an ensemble of input points and output coordinates.  Assume a total of \(P\) points, \(\vec{r_0}, \vec{r_1}, \hdots \vec{r_P}\).
  \begin{equation}
    \label{eqn:defcA}
    \vec{c} = \begin{bmatrix}
                c_0 \\
                c_1 \\
                \vdots \\
                c_N
              \end{bmatrix} \quad\quad\quad
    \mat{A} = \begin{bmatrix}
                B_0(\vec{r_1}) && B_1(\vec{r_1}) && \hdots && B_N(\vec{r_1}) \\
                B_0(\vec{r_2}) && B_1(\vec{r_2}) && \hdots && B_N(\vec{r_2}) \\
                \vdots && \vdots && \ddots && \vdots \\
                B_0(\vec{r_P}) && B_1(\vec{r_P}) && \hdots && B_N(\vec{r_P}) \\
              \end{bmatrix}
  \end{equation}
  \begin{equation}
    \begin{bmatrix}
      f(\vec{r_1}) \\
      f(\vec{r_2}) \\
      \vdots \\
      f(\vec{r_P})
    \end{bmatrix} =
    \begin{bmatrix}
      B_0(\vec{r_1}) && B_1(\vec{r_1}) && \hdots && B_N(\vec{r_1}) \\
      B_0(\vec{r_2}) && B_1(\vec{r_2}) && \hdots && B_N(\vec{r_2}) \\
      \vdots && \vdots && \ddots && \vdots \\
      B_0(\vec{r_P}) && B_1(\vec{r_P}) && \hdots && B_N(\vec{r_P}) \\
    \end{bmatrix}
    \begin{bmatrix}
      c_0 \\
      c_1 \\
      \vdots \\
      c_N
    \end{bmatrix}
  \end{equation}
  \begin{equation}
    \vec{f} = \mat{A}\vec{c}
  \end{equation}
  This form also makes it easy to calculate gradients, \(\nabla f\).  Because the coefficients \(c_n\) are constant, you only need to take the gradient of the 3D basis functions, \(B_n(\vec{r})\) in the summation.
  \[\nabla f(\vec{r}) = \sum_{n=0}^N c_n \nabla B_n(\vec{r})\]
  Following the conventions from above, define a new matrix of the gradients of basis function.
  \[\mat{A_g} = \begin{bmatrix}
                \nabla B_0(\vec{r_1}) && \nabla B_1(\vec{r_1}) && \hdots && \nabla B_N(\vec{r_1}) \\
                \nabla B_0(\vec{r_2}) && \nabla B_1(\vec{r_2}) && \hdots && \nabla B_N(\vec{r_2}) \\
                \vdots && \vdots && \ddots && \vdots \\
                \nabla B_0(\vec{r_P}) && \nabla B_1(\vec{r_P}) && \hdots && \nabla B_N(\vec{r_P}) \\
              \end{bmatrix}\]
  \[\vec{\nabla f} = \mat{A_g}\vec{c}\]


  The 3D basis functions used are composed of an exponentially decaying Laguerre polynomial vertically (\(e^{-z}L_k(z)\)) multiplied by real-valued spherical cap harmonic functions (\(Y_{\nu m}(\theta,\phi)\)).
  \begin{equation}
    B_n(\vec{r}) = e^{-z}L_k(z)Y_{\nu m}(\theta,\phi)
  \end{equation}

  \subsection{Spherical Cap Harmonics}
  Spherical cap harmonics are spherical harmonics functions that have been modified to have a range of a small area (or "cap") on a sphere instead of over the entire globe.  This allows higher resolution over a small area using much fewer degrees than a full spherical harmonics expansion would require.  The initial use of spherical cap harmonics in geophysics is detailed in \citet{Haines1985}.  Other useful sources include \citet{DeSantis1991,Thebault2006}.

  Spherical cap harmonics are just spherical harmonic functions where the degree (typically denoted as \(l\)) is allowed to be any positive real value.  To make this distinction clear, the non-integer degree in spherical cap harmonics is denoted with \(\nu\), but \(l\) is still used to index the functions.  The value of \(\nu\) can be found by enforcing certain boundary conditions at the edge of the cap.
  \begin{align}
    P_\nu^m(\cos(\theta_{cl})) = 0 \quad &l-m\:\text{odd} \\
    \frac{dP_\nu^m(\cos(\theta))}{d\theta}|_{\theta_{cl}} = 0 \quad &l-m\:\text{even}
  \end{align}
  These can be solved using an root-finding algorithm, but it is much more convenient to used the following approximation \citep{Thebault2006}.
  \begin{equation}
    \nu(l) \approx \left(2l+\frac{1}{2}\right)\frac{\pi}{2\theta_{cl}}-\frac{1}{2}
  \end{equation}

  In total, real-valued spherical cap harmonics can be expressed as follows.
  \begin{equation}
    \label{eqn:spharm}
    Y_{\nu m}(\theta,\phi) = \begin{cases}
                                K_{\nu |m|}P_\nu^{|m|}(\cos\theta)\sin(|m|\phi) & m < 0 \\
                                K_{\nu m}P_\nu^{m}(\cos\theta) & m = 0 \\
                                K_{\nu m}P_\nu^{m}(\cos\theta)\cos(m\phi) & m > 0
                             \end{cases}
  \end{equation}
  \begin{equation}
    K_{\nu m} = \sqrt{\frac{2\nu+1}{4\pi}\frac{\Gamma(\nu-m+1)}{\Gamma(\nu+m+1)}}
  \end{equation}
  It is convenient to define a new azimuthal function, \(A_{\nu m}(\phi)\), which contains both the discontinuous \(\phi\) dependence and the constant \(K_{\nu m}\).  This both makes the expression look cleaner and puts it in a clearly separable form.
  \begin{equation}
    \label{eqn:A}
    A_{\nu m}(\phi) = \begin{cases}
                        K_{\nu |m|}\sin(|m|\phi) & m < 0 \\
                        K_{\nu m} & m = 0 \\
                        K_{\nu m}\cos(m\phi) & m > 0
                      \end{cases}
  \end{equation}

  Real-valued spherical harmonics are used here instead of their more traditional complex counterparts to avoid the computational complications of complex numbers.  Although modern computer languages like python have built-in functionality for complex numbers, maintaining a base method that uses only real numbers makes it easier to translate this code into lower-level languages, such as C, if speed ever becomes an important concern.

  \subsection{Laguerre Polynomials}
  \label{sec:laguerre}
  Laguerre polynomials, \(L_k(z)\), are sensitive to variations approximately in the range \((0,10)\).  The native coordinates of the data are in meters from the center of the Earth, which corresponds approximately to a range of \(6.3\times10^6,7\times10^6\).  Essentially, the ionosphere is a thin shell over the surface of the Earth in a range that Laguerre polynomials are not sensitive to variations at all, so the data must be transformed into coordinates where the polynomials are "well behaved".  If the altitude (or radial distance) of a point is originally expressed in the geocentric coordinate \(r\), the following transformation is used.
  \begin{equation}
    \label{eqn:rtransform}
    z = 100\left(\frac{r}{R_E}-1\right)
  \end{equation}
  This essentially stretches and shifts the input geocentric coordinates to be in a range of approximately \((0,10)\).  This is a useful trick, but does introduce complications when calculating the gradients (see Section ...).

  Laguerre polynomials go to infinity as \(z\) approaches infinity, so instead, weighted Laguerre polynomials, \(e^{-z/2}L_k(z)\) are used.  Weighted Laguerre polynomials go to zero as \(z\rightarrow\infty\), which works well for electron density which is expected to physically decrease at high altitudes, but not for temperature, which actually increases.  The consequence of this is that for temperature particularly, the model CANNOT be trusted at altitudes higher than the range of the data, which constrains the fit.  There are some additional complications regarding the regularization as well, but these will be discussed in Section ...

  \subsection{3D Basis Functions}
  The full 3D basis functions have the following form.
  \begin{equation}
    \label{eqn:basis}
    B_n = e^{-\frac{z}{2}}L_k(z)P_\nu^m(\cos\theta)A_{\nu m}(\phi)
  \end{equation}
  The basis functions are indexed by \(k\) (the radial index number), \(l\) (the longitudinal index number), and \(m\) (the azimuthal index number), where \(\nu\) is a function of \(l\).  Each 3D index number, \(n\), corresponds to one specific set of \((k,l,m)\).  The total number of 3D basis functions is defined by the maximum number of radial indices (\(k_{max}\)) and the maximum number of longitudinal indices (\(l_{max}\)), both selected by the user.
  \begin{equation}
    N = k_{max} \times l_{max}^2
  \end{equation}
  Note that because indexing starts at 0, the actual maximum values of \(k\) and \(l\) will be \(k_{max}-1\) and \(l_{max}-1\), respectively.  The value of \(n\) doesn't end up factoring into the calculated basis functions at all, so the exact method in which \(n\) maps to \((k,l,m)\) is not important, but it MUST be consistent throughout all processes and functions.  This is handled in \texttt{Model.eval\_basis()} with the following convection.
  \begin{align}
    k =& \text{floor}\left(\frac{n}{l_{max}^2}\right) \\
    l =& \text{floor}\left(\sqrt{n \% l_{max}^2}\right) \\
    m =& n \% l_{max}^2 - l(l+1)
  \end{align}
  As an example, if \(k_{max} = 2\) and \(l_{max} = 3\), there are a total of \(N = 18\) 3D basis functions used with the index mapping displayed in Table ...
  \begin{center}
    \begin{tabular}{c c c c}
      n & k & l & m \\
      \hline
      0 & 0 & 0 & 0 \\
      1 & 0 & 1 & -1 \\
      2 & 0 & 1 & 0 \\
      3 & 0 & 1 & 1 \\
      4 & 0 & 2 & -2 \\
      5 & 0 & 2 & -1 \\
      6 & 0 & 2 & 0 \\
      7 & 0 & 2 & 1 \\
      8 & 0 & 2 & 2 \\
      9 & 1 & 0 & 0 \\
      10 & 1 & 1 & -1 \\
      11 & 1 & 1 & 0 \\
      12 & 1 & 1 & 1 \\
      13 & 1 & 2 & -2 \\
      14 & 1 & 2 & -1 \\
      15 & 1 & 2 & 0 \\
      16 & 1 & 2 & 1 \\
      17 & 1 & 2 & 2 \\
    \end{tabular}
  \end{center}

  \subsection{Coordinates}
  The input data should be in geocentric coordinates (\(r\) in meters, \(\theta\) and \(\phi\) in radians), but due to limitations in the modeling functions used, calculations within the model must be done in special ``model'' coordinates.  As detailed in Section \ref{sec:laguerre}, the data must be ``stretched'' radially according to Equation \ref{eqn:rtransform}.  Additionally, because the Spherical Cap Harmonics (Equation \ref{eqn:spharm}) are centered around the north pole, the data must be rotated on the sphere to be similarly centered.  This is done through the Rodriguez' rotation formula.
  \begin{equation}
    \vec{v}_{rot} = \vec{v}\cos\theta + (\vec{k}\times\vec{v})\sin\theta + \vec{k}(\vec{k}\cdot\vec{v})(1-\cos\theta)
  \end{equation}
  Here, \(\vec{v}\) is the original vector, \(\vec{k}\) is a unit vector describing the axis of rotation, and \(\theta\) is the angle by which \(\vec{v}\) is rotated.  For this application, the center of an AMISR FoV in a particular mode (the center point) is found by calculating the average colatitude (\(\theta_{cp}\)) and the average azimuth (\(\phi_{cp}\)) of the data points.  Then the angle that the points must be rotated through is given by \(\theta_{cp}\) and the rotation axis is in the plane of the equator at an angle of \(\phi_{cp}+\pi/2\).

  \subsection{Gradients}
  The 3D basis functions are given in Equation \ref{eqn:basis}.  They are used to calculate the scalar value of parameters given the fitted coefficient vector \(\vec{c}\).  The gradients of the 3D basis functions are needed to calculate gradients of the parameters.  The expressions are shown below, but details of their derivation are reserved for Appendix \ref{app:gradients}.
  \begin{equation}
    B_n = e^{-\frac{z}{2}}L_k(z)P_\nu^m(\cos\theta)A_{\nu m}(\phi)
  \end{equation}
  \begin{align}
    (\nabla B_n)_r &= -e^{-\frac{z}{2}}\left[\frac{1}{2}L_k(z)+L_{k-1}^1(z)\right]P_\nu^m(\cos\theta)A_{\nu m}(\phi)\frac{100}{R_E} \\
    (\nabla B_n)_\theta &= \frac{1}{R_E(z/100+1)\sin\theta}e^{-\frac{z}{2}}L_k(z)\left[\nu\cos\theta P_\nu^m(\cos\theta)-(m+\nu)P_{\nu-1}^m(\cos\theta)\right]A_{\nu m}(\phi) \\
    (\nabla B_n)_\phi &= -\frac{m}{R_E(z/100+1)\sin\theta}e^{-\frac{z}{2}}L_k(z)P_\nu^m(\cos\theta)dA_{\nu m}(\phi)
  \end{align}
  The derivative azimuthal function, \(dA_{\nu m}(\phi)\), is defined as follows.
  \begin{equation}
    \label{eqn:dA}
    dA_{\nu m}(\phi) = \begin{cases}
                        K_{\nu |m|}\cos(|m|\phi) & m < 0 \\
                        0 & m = 0 \\
                        K_{\nu m}\sin(m\phi) & m > 0
                      \end{cases}
  \end{equation}



\section{Fit}
  The model is fit to a particular data set by finding the coefficient vector \(\vec{c}\) that minimizes the square of the residuals.  This is a standard least-squares optimization problem.
  \begin{equation}
    \label{eqn:residuals}
    \text{min}\left\{\sum_i\left(\frac{d_i-f(\vec{r}_i)}{\sigma_i}\right)^2\right\}
  \end{equation}
  Here, \(\vec{r}_i\), \(d_i\), and \(\sigma_i\) are the position, value, and error of a given point in the data and \(f(\vec{r}_i)\) is the model evaluated at that point.  It can be shown that equation \ref{eqn:residuals} is equivalent to finding the least-squares solution to the following matrix equation.
  \begin{equation}
    \label{eqn:noreg}
    \mat{A}^\dagger\mat{W}\mat{A}\vec{c} = \mat{A}^\dagger\mat{W}\vec{d}
  \end{equation}
  Here, \(\vec{d}\) is the vector of data points and \(\mat{W}\) is the matrix of the inverse of their errors squared.
  \begin{equation}
    \vec{d} = \begin{bmatrix}
                d_1 \\
                d_2 \\
                \vdots \\
                d_P
              \end{bmatrix} \quad\quad\quad
    \mat{W} = \begin{bmatrix}
                1/\sigma_1^2 && 0 && \hdots && 0 \\
                0 && 1/\sigma_2^2 && \hdots && 0 \\
                \vdots && \vdots && \ddots && \vdots \\
                0 && 0 && \hdots && 1/\sigma_P^2 \\
              \end{bmatrix}
  \end{equation}
  \(\mat{A}\) and \(\vec{c}\) have been defined previously in Equation \ref{eqn:defcA}.

  The solution to Equation \ref{eqn:noreg} can be expressed in closed form by multiplying both sides by the inverse of \(\mat{A}^\dagger\mat{W}\mat{A}\).
  \begin{equation}
    \vec{c} = (\mat{A}^\dagger\mat{W}\mat{A})^{-1}\mat{A}^\dagger\mat{W}\vec{d}
  \end{equation}
  However, numerically inverting matrices is usually a bad idea (\url{https://www.johndcook.com/blog/2010/01/19/dont-invert-that-matrix/}), so instead, solve Equation \ref{eqn:noreg} directly with a standard linear algebra equation solver (e.g. \plaintext{scipy.linalg.lstsq}).

  \subsection{Regularization}
  Regularization refers to a variety of techniques that are used to try to ensure that the model gives a reasonable estimation for reality even when the data coverage is sparse.  Typically, it involves making some kind of assumption about the system and adding a term to the residual equation so that solutions that are not very close to that assumption are penalized.  This modifies Equation \ref{eqn:residuals}.
  \begin{equation}
    \label{eqn:residualswreg}
    \text{min}\left\{\sum_i\left(\frac{d_i-f(\vec{r}_i)}{\sigma_i}\right)^2+\alpha\Gamma(\vec{r}_i)\right\}
  \end{equation}
  Here, \(\Gamma\) is some function that defines the regularization and \(\alpha\) is a constant, the regularization parameter, that determines how heavily the model is regularized.  This is useful for preventing things like over-fitting, where the model hits almost all the data exactly by oscillating wildly between points.  Two types of regularization are utilized here: curvature and zeroth-order.

  \subsection{Curvature}
    Curvature regularization is a relatively common technique, which attempts to minimize the curvature of the output model to reduce the number of sharp direction changes, which is often a symptom of over-fitting.  Instead of computing the actual curvature, usually just the second derivative squared (or in the case of a 3D function, the Laplacian squared) is used.
    \begin{equation}
      \label{eqn:residualcurvature}
      \Gamma = \int \nabla^2f(\vec{r})d\vec{r}
    \end{equation}
    In matrix notation, this is equivalent to the following term, which is added to the left hand side of Equation \ref{eqn:noreg}.
    \begin{equation}
      \label{eqn:curvereg}
      \Gamma = \mat{\Omega}\vec{c}
    \end{equation}
    \(\mat{\Omega}\) is a matrix of the integral of the product of the Laplacian of two basis functions.
    \begin{equation}
      \label{eqn:defOmg}
      \mat{\Omega} = \begin{bmatrix}
                  \int (\nabla^2B_0(\vec{r}))^2 d\vec{r} && \int \nabla^2B_0(\vec{r})\nabla^2B_1(\vec{r}) d\vec{r} && \hdots && \int \nabla^2B_0(\vec{r})\nabla^2B_N(\vec{r}) d\vec{r} \\
                  \int \nabla^2 B_1(\vec{r})\nabla^2 B_0(\vec{r}) d\vec{r} && \int (\nabla^2B_1(\vec{r}))^2 d\vec{r} && \hdots && \int \nabla^2B_1(\vec{r})\nabla^2B_N(\vec{r}) d\vec{r} \\
                  \vdots && \vdots && \ddots && \vdots \\
                  \int \nabla^2 B_N(\vec{r})\nabla^2 B_0(\vec{r}) d\vec{r} && \int \nabla^2B_N(\vec{r})\nabla^2B_1(\vec{r}) d\vec{r} && \hdots && \int (\nabla^2B_N(\vec{r}))^2 d\vec{r} \\
                \end{bmatrix}
    \end{equation}
    The Laplacian of the 3D basis function is computed in Appendix \ref{app:laplacian}.
    \begin{align}
      \label{eqn:fulllaplacian}
      \nabla^2B_n(\vec{r}) =& \left(\frac{100}{R_E}\right)^2\frac{1}{r}\left[2\left(\frac{R_E}{100}\right)\frac{\partial Z}{\partial z}+r\frac{\partial^2 Z}{\partial z^2}\right]P_\nu^m(\cos\theta)A_{\nu m}(\phi) \\
      &+ e^{-\frac{z}{2}}L_k(z)\frac{1}{r^2}\Theta(\theta)A_{\nu m}(\phi) \\
      &+ e^{-\frac{z}{2}}L_k(z)\frac{-m^2}{r^2\sin^2\theta}P_\nu^m(\cos\theta)A_{\nu m}(\phi)
    \end{align}
    \begin{align}
      \frac{\partial Z}{\partial z} &= -e^{-\frac{z}{2}}L_k(z)\left[\frac{1}{2}L_k(z)+L_{k-1}^1(z)\right] \\
      \frac{\partial^2 Z}{\partial z^2} &= e^{-\frac{z}{2}}L_k(z)\left[\frac{1}{4}L_k(z)+L_{k-1}^1(z)+L_{k-2}^2(z)\right] \\
      \Theta(\theta) &= \frac{1}{\sin^2\theta}\left[(m^2-\nu^2(\cos^2\theta+1)-\nu)P_\nu^m(\cos\theta)+\nu(\nu+m)\cos\theta P_{\nu-1}^m(\cos\theta)+\nu(\nu-m+1)\cos\theta P_{\nu+1}^m(\cos\theta)\right]
    \end{align}
    If Equation \ref{eqn:fulllaplacian} isn't unwieldy enough, each element of \(\mat{\Omega}\) is the volumetric integral of the product of two 3D basis function Laplacians.  The resulting integrand is extremely messy and can only be solved numerically.  However, due to the number of coupled terms including special functions, the required triple integral is actually quite computationally expensive.

    Instead of regularizing with the computationally expensive full Laplacian, use a modified ``perpendicular'' Laplacian.  This is very similar to the standard Laplacian in spherical coordinates, but set all radial derivatives to zero.  The assumption that \(\partial/\partial r = 0\) is meant less to indicate that no gradients are expected in the radial direction (quite the contrary, this is the ONLY direction in which variation is expected at all times) but more that we are not concerned about over-fitting in this direction.  Furthermore, the zeroth-order regularization should take care of smoothing the model radially.
    \begin{equation}
      \label{eqn:reglaplacian}
      \nabla_\perp^2 B_n(\vec{r}) = \frac{e^{-\frac{z}{2}}}{z^2}L_k(z)\Theta'_{\nu m}(\theta)A_{\nu m}(\phi)
    \end{equation}
    \begin{equation}
      \Theta'_{\nu m}(\theta) = \frac{1}{\sin^2\theta}\left[-\nu(\nu\cos^2\theta+\nu+1)P_\nu^m(\cos\theta)+\nu(\nu+m)\cos\theta P_{\nu-1}^m(\cos\theta)+\nu(\nu-m+1)\cos\theta P_{\nu+1}^m(\cos\theta)\right]
    \end{equation}
    The details of this derivation are also included in Appendix \ref{app:laplacian}.

    Each element in the curvature regularization matrix \(\mat{\Omega}\) (Equation \ref{eqn:defOmg}) consists of the integral of the product of the Laplacians of two independent basis functions.
    \begin{align}
      \Omega_{ij} &= \int \nabla_\perp^2 B_i(\vec{r}) \nabla_\perp^2 B_j(\vec{r}) d\vec{r} \\
      &= \int \left[\frac{e^{-\frac{z}{2}}}{z^2}L_{k_i}(z)\Theta'_{\nu_i m_i}(\theta)A_{\nu_i m_i}(\phi)\right]\left[\frac{e^{-\frac{z}{2}}}{z^2}L_{k_j}(z)\Theta'_{\nu_j m_j}(\theta)A_{\nu_j m_j}(\phi)\right]z^2\sin\theta dz d\theta d\phi \\
      &= \int \frac{e^{-z}}{z^2}L_{k_i}(z)L_{k_j}(z)dz \int \Theta'_{\nu_i m_i}(\theta)\Theta'_{\nu_j m_j}(\theta)\sin\theta d\theta \int A_{\nu_i m_i}(\phi)A_{\nu_j m_j}(\phi)d\phi
    \end{align}
    The fact that this can separate into three single integrals instead of one triple integral is actually a huge computational advantage.

  \subsection{Zeroth Order}
    In zeroth order regularization, minimize the difference between the output model and a set function that represents a very basic, "zeroth order" approximation of what the output model is expected to be.  This is essentially making an au priori assumption about what the output model SHOULD look like, and then allowing perturbations to that model to fit the data.  In the ionosphere, where there are often established, first-principle based approximate models of various parameters, this kind of regularization is particularly appropriate.
    \begin{equation}
      \label{eqn:residualzerothorder}
      \Gamma = \int \left(f(\vec{r})-\delta(\vec{r})\right)^2 d\vec{r}
    \end{equation}
    The function \(\delta(\vec{r})\) represents whatever zeroth order model is appropriate for a given parameter.  Although these can be 3D functions, horizontal variation is difficult to guess a priori (hence the need for a data based fit), so simple models of the profile in altitude are perfectly appropriate.  For electron density, a standard Chapman function is chosen (Equation \ref{eqn:denszerothorder}) while an inverse hyperbolic sine function represents the general shape of the temperature profile (Equation \ref{eqn:tempzerothorder}).
    \begin{equation}
      \label{eqn:denszerothorder}
      \delta(\vec{r}) = Ae^{1-\frac{z-B}{H}-e^{-\frac{z-B}{H}}}
    \end{equation}
    \begin{equation}
      \label{eqn:tempzerothorder}
      \delta(\vec{r}) = A\sinh^{-1}\left(\frac{x-B}{H}\right)+C
    \end{equation}
    The constants in Equations \ref{eqn:denszerothorder} and \ref{eqn:tempzerothorder} are found by doing a non-linear least-squares fit to the raw data.

    In matrix form, Equation \ref{eqn:residualzerothorder} is equivalent to the following, which is added to the left-hand side of Equation \ref{eqn:noreg}.
    \begin{equation}
      \label{eqn:zeroordreg}
      \Gamma = \mat{\Psi}\vec{c} - \vec{\Upsilon}
    \end{equation}
    \(\mat{\Psi}\) is a matrix composed of the integral of the product of two basis functions.
    \begin{equation}
      \label{eqn:defPsi}
      \mat{\Psi} = \begin{bmatrix}
                  \int (B_0(\vec{r}))^2 d\vec{r} && \int B_0(\vec{r})B_1(\vec{r}) d\vec{r} && \hdots && \int B_0(\vec{r})B_N(\vec{r}) d\vec{r} \\
                  \int B_1(\vec{r})B_0(\vec{r}) d\vec{r} && \int (B_1(\vec{r}))^2 d\vec{r} && \hdots && \int B_1(\vec{r})B_N(\vec{r}) d\vec{r} \\
                  \vdots && \vdots && \ddots && \vdots \\
                  \int B_N(\vec{r})B_0(\vec{r}) d\vec{r} && \int B_N(\vec{r})B_1(\vec{r}) d\vec{r} && \hdots && \int (B_N(\vec{r}))^2 d\vec{r} \\
                \end{bmatrix}
    \end{equation}
    \(\vec{\Upsilon}\) is a vector composed of the integral of the product of a basis function and the zeroth order function, \(\delta(\vec{r}\).
    \begin{equation}
      \label{eqn:defUps}
      \vec{\Upsilon} = \begin{bmatrix}
                  \int B_0(\vec{r})\delta(\vec{r}) d\vec{r} \\
                  \int B_1(\vec{r})\delta(\vec{r}) d\vec{r} \\
                  \vdots \\
                  \int B_N(\vec{r})\delta(\vec{r}) d\vec{r} \\
                \end{bmatrix}
    \end{equation}
    Each element in the matrix \(\mat{\Psi}\) (Equation \ref{eqn:defPsi}) consists of the integral of two independent basis functions.
    \begin{align}
      \Psi_{ij} &= \int B_i(\vec{r})B_j(\vec{r}) d\vec{r} \\
      &= \int \left[e^{-\frac{z}{2}}L_{k_i}(z)P_{\nu_i}^{m_i}(\cos\theta)A_{\nu_i m_i}(\phi)\right]\left[e^{-\frac{z}{2}}L_{k_j}(z)P_{\nu_j}^{m_j}(\cos\theta)A_{\nu_j m_j}(\phi)\right] z^2 \sin\theta dz d\theta d\phi \\
      &= \int e^{-z}L_{k_i}(z)L_{k_j}(z)z^2 dz \int P_{\nu_i}^{m_i}(\cos\theta)P_{\nu_j}^{m_j}(\cos\theta) \sin\theta d\theta \int A_{\nu_i m_i}(\phi)A_{\nu_j m_j}(\phi) d\phi
    \end{align}
    Similarly, if \(\delta(\vec{r})\) is separable or a 1D f each element in \(\vec{\Upsilon}\) can also be expressed as the product of 1D integrals.
    \begin{align}
      \Upsilon_{n} &= \int B_n(\vec{r})\delta(\vec{r}) d\vec{r} \\
      &= \int \left[e^{-\frac{z}{2}}L_k(z)P_\nu^m(\cos\theta)A_{\nu m}(\phi)\right]\delta(z) z^2 \sin\theta dz d\theta d\phi \\
      &= \int e^{-\frac{z}{2}}L_k(z)\delta(z)z^2 dz \int P_\nu^m(\cos\theta)\sin\theta d\theta \int A_{\nu m}(\phi) d\phi
    \end{align}
    Similar to the curvature regularization case, the fact that both \(\mat{\Psi}\) and \(\vec{\Upsilon}\) can be calculated as a product of 1D integrals in computationally advantageous.




\appendix

\section{Derivation of Gradients of 3D Basis Function}
  \label{app:gradients}
  The 3D basis function has the following form (Equation \ref{eqn:basis})
  \begin{equation}
    B_n = e^{-\frac{z}{2}}L_k(z)P_\nu^m(\cos\theta)A_{\nu m}(\phi)
  \end{equation}
  where
  \begin{equation}
    z = 100\left(\frac{r}{R_E}-1\right)
  \end{equation}.
  Using the standard expression for the gradient in a spherical coordinate system,
  \begin{align}
    (\nabla B_n)_r &= \frac{\partial B_n}{\partial r} = \frac{\partial B_n}{\partial z}\frac{\partial z}{\partial r} \\
    (\nabla B_n)_\theta &= \frac{1}{r}\frac{\partial B_n}{\partial \theta} \\
    (\nabla B_n)_\phi &= \frac{1}{r\sin\theta}\frac{\partial B_n}{\partial \phi}
  \end{align}
  The scaling factor and \(r\) can be expressed in terms of the model coordinate \(z\).
  \begin{equation}
    r = R_E\left(\frac{z}{100}+1\right) \quad\quad\quad \frac{\partial z}{\partial r} = \frac{100}{R_E}
  \end{equation}

  The radial component requires calculation of the derivative \(\partial B_n/\partial z\).
  \begin{align}
    \frac{\partial B_n}{\partial z} &= \frac{\partial}{\partial z}\left[e^{-\frac{z}{2}}L_k(z)\right]P_\nu^m(\cos\theta)A_{\nu m}(\phi) \\
     &= \left[\left(-\frac{1}{2}\right)e^{-\frac{z}{2}}L_k(z) + e^{-\frac{z}{2}}\left(-L_{k-1}^1(z)\right)\right]P_\nu^m(\cos\theta)A_{\nu m}(\phi) \\
     &= -e^{-\frac{z}{2}}\left[\frac{1}{2}L_k(z)+L_{k-1}^1(z)\right]P_\nu^m(\cos\theta)A_{\nu m}(\phi)
  \end{align}
  \begin{equation}
    (\nabla B_n)_r = -e^{-\frac{z}{2}}\left[\frac{1}{2}L_k(z)+L_{k-1}^1(z)\right]P_\nu^m(\cos\theta)A_{\nu m}(\phi)\frac{100}{R_E}
  \end{equation}

  The latitudinal component requires the calculation of \(\partial B_n/\partial \theta\).
  \begin{align}
    \frac{\partial B_n}{\partial \theta} &= e^{-\frac{z}{2}}L_k(z)\frac{\partial}{\partial \theta}\left[P_\nu^m(\cos\theta)\right]A_{\nu m}(\phi) \\
     &= e^{-\frac{z}{2}}L_k(z)\frac{1}{\sin\theta}\left[\nu\cos\theta P_\nu^m(\cos\theta) - (\nu+m)P_{\nu-1}^m(\cos\theta)\right]A_{\nu m}(\phi)
  \end{align}
  \begin{equation}
    (\nabla B_n)_\theta = \frac{1}{R_E(z/100+1)\sin\theta}e^{-\frac{z}{2}}L_k(z)\left[\nu\cos\theta P_\nu^m(\cos\theta)-(m+\nu)P_{\nu-1}^m(\cos\theta)\right]A_{\nu m}(\phi)
  \end{equation}

  The azimuthal component requires the calculation of \(\partial B_n/\partial \phi\).
  \begin{align}
    \frac{\partial B_n}{\partial \phi} &= e^{-\frac{z}{2}}L_k(z)P_\nu^m(\cos\theta)\frac{\partial}{\partial \phi}\left[A_{\nu m}(\phi)\right]
  \end{align}
  \(A_{\nu m}(\phi)\) is a piece-wise function defined in Equation \ref{eqn:A}
  \begin{align}
    \frac{\partial}{\partial \phi}\left[A_{\nu m}(\phi)\right] &= \begin{cases}
                        \frac{\partial}{\partial \phi}\left[K_{\nu |m|}\sin(|m|\phi)\right] & m < 0 \\
                        \frac{\partial}{\partial \phi}\left[K_{\nu m}\right] & m = 0 \\
                        \frac{\partial}{\partial \phi}\left[K_{\nu m}\cos(m\phi)\right] & m > 0
                      \end{cases} \\
    &= \begin{cases}
      |m| K_{\nu |m|}\cos(|m|\phi) & m < 0 \\
      0 & m = 0 \\
      -m K_{\nu m}\sin(m\phi) & m > 0
    \end{cases} \\
    &= -m \begin{cases}
      K_{\nu |m|}\cos(|m|\phi) & m < 0 \\
      0 & m = 0 \\
      K_{\nu m}\sin(m\phi) & m > 0
    \end{cases}
  \end{align}
  Using the definition for \(dA_{\nu m}(\phi)\) given in Equation \ref{eqn:dA}, \(\partial B_n/\partial \phi\) can be expressed in a much cleaner form.
  \begin{equation}
    \frac{\partial B_n}{\partial \phi} = -m e^{-\frac{z}{2}}L_k(z)P_\nu^m(\cos\theta)dA_{\nu m}(\phi)
  \end{equation}
  \begin{equation}
    (\nabla B_n)_\phi = -\frac{m}{R_E(z/100+1)\sin\theta}e^{-\frac{z}{2}}L_k(z)P_\nu^m(\cos\theta)dA_{\nu m}(\phi)
  \end{equation}

\section{Derivation of the Laplacian of 3D Basis Function}
  \label{app:laplacian}

  \subsection{Full Laplacian}
  The Laplacian in spherical coordinates has the following general form.
  \begin{equation}
    \nabla^2 f = \frac{1}{r^2}\frac{\partial}{\partial r}\left(r^2\frac{\partial f}{\partial r}\right) + \frac{1}{r^2\sin\theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial f}{\partial\theta}\right) + \frac{1}{r^2\sin^2\theta}\frac{\partial^2 f}{\partial\phi^2}
  \end{equation}
  The 3D basis function has the following form (Equation \ref{eqn:basis})
  \begin{equation}
    B_n = e^{-\frac{z}{2}}L_k(z)P_\nu^m(\cos\theta)A_{\nu m}(\phi)
  \end{equation}
  where
  \begin{equation}
    z = 100\left(\frac{r}{R_E}-1\right)
  \end{equation}.
  In taking the Laplacian of a single basis function, the chain rule must be employed due to the \(z\) transformation.
  \begin{equation}
    \frac{\partial B_n}{\partial r} = \frac{\partial B_n}{\partial z}\frac{\partial z}{\partial r}
  \end{equation}
  Apply this to the first term in the general Laplacian equation.
  \begin{align}
    \frac{1}{r^2}\frac{\partial}{\partial r}\left(r^2 \frac{\partial B_n}{\partial r}\right) &= \frac{\partial}{\partial z}\left(r^2 \frac{\partial B_n}{\partial z}\frac{\partial z}{\partial r}\right) \frac{\partial z}{\partial r} \frac{1}{r} \\
    &= \left[2r\frac{\partial r}{\partial z}\left(\frac{\partial B_n}{\partial z}\frac{\partial z}{\partial r}\right) + r^2\frac{\partial^2 B_n}{\partial z^2}\frac{\partial z}{\partial r}\right]\frac{\partial z}{\partial r}\frac{1}{r} \\
    &= \left(\frac{\partial z}{\partial r}\right)^2\frac{1}{r}\left[2\frac{\partial r}{\partial z}\frac{\partial B_n}{\partial z} + r\frac{\partial^2 B_n}{\partial z^2}\right]
  \end{align}
  Calculate the first and second derivatives of the basis function.
  \begin{align}
    \frac{\partial B_n}{\partial z} &= -e^{-\frac{z}{2}}\left[\frac{1}{2}L_k(z)+L_{k-1}^1(z)\right]P_\nu^m(\cos\theta)A_{\nu m}(\phi) \\
    \frac{\partial^2 B_n}{\partial z^2} &= e^{-\frac{z}{2}}\left[\frac{1}{4}L_k(z)+L_{k-1}^1(z)+L_{k-2}^2\right]P_\nu^m(\cos\theta)A_{\nu m}(\phi)
  \end{align}
  For simplicity, define the function \(Z(z)\) such that
  \begin{align}
    \frac{\partial Z}{\partial z} &= -e^{-\frac{z}{2}}\left[\frac{1}{2}L_k(z)+L_{k-1}^1(z)\right] \\
    \frac{\partial^2 Z}{\partial z^2} &= e^{-\frac{z}{2}}\left[\frac{1}{4}L_k(z)+L_{k-1}^1(z)+L_{k-2}^2\right]
  \end{align}
  Substitute the expressions for the basis function derivatives back into the first term of the Laplacian.
  \begin{equation}
    \frac{1}{r^2}\frac{\partial}{\partial r}\left(r^2\frac{\partial B_n}{\partial r}\right) = \left(\frac{100}{R_E}\right)^2\frac{1}{r}\left[2\left(\frac{R_E}{100}\right)\frac{\partial Z}{\partial z} + r\frac{\partial^2 Z}{\partial z^2}\right]P_\nu^m(\cos\theta) A_{\nu m}(\phi)
  \end{equation}

  Consider the second term in the Laplacian
  \begin{equation}
    \frac{\partial B_n}{\partial \theta} = e^{-\frac{z}{2}}L_k(z)\frac{\partial P_\nu^m(\cos\theta)}{\partial \theta}A_{\nu m}(\phi)
  \end{equation}
  To evaluate the derivative of the Legendre polynomial, first make the substitution \(x=\cos\theta\) such that \(\frac{\partial x}{\partial \theta} = -\sin\theta\) and \(\frac{\partial P_\nu^m}{\partial \theta} = \frac{\partial P_\nu^m}{\partial x}\frac{\partial x}{\partial \theta} = -\sin\theta\frac{\partial P_\nu^m}{\partial x}\) and then evaluate \(\frac{\partial P_\nu^m}{\partial x}\) using the standard properties of Legendre polynomials.
  \begin{align}
    \frac{\partial P_\nu^m}{\partial x} & = \frac{1}{x^2-1}\left(x\nu P_\nu^m(x)-(\nu+m)P_{\nu-1}^m(x)\right) \\
    \frac{\partial P_\nu^m}{\partial \theta} &= \frac{1}{\sin\theta}\left[\nu\cos\theta P_\nu^m(\cos\theta)-(\nu+m)P_{\nu-1}^m(\cos\theta)\right]
  \end{align}
  Folding this result into the entire second term in the Laplacian yields the following.
  \begin{equation}
    \frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial B_n}{\partial \theta}\right) = e^{-\frac{z}{2}}L_k(z)\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial P_\nu^m}{\partial\theta}\right)A_{\nu m}(\phi)
  \end{equation}
  Consider only the derivatives in \(\theta\).
  \begin{align}
    &\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial P_\nu^m}{\partial\theta}\right) = \frac{\partial}{\partial\theta}\left[\nu\cos\theta P_\nu^m(\cos\theta)-(\nu+m)P_{\nu-1}^m(\cos\theta)\right] \\
    &= \frac{\partial}{\partial x}\left[\nu x P_\nu^m(x)-(\nu+m)P_{\nu-1}^m(x)\right]\frac{\partial x}{\partial\theta} \\
    &= \frac{1}{x^2-1}\left[-\left(\nu^2(x^2+1)+\nu-m^2\right)P_\nu^m(x) + \nu x(\nu+m)P_{\nu-1}^m(x) + \nu x(\nu-m+1)P_{\nu+1}^m(x)\right]\frac{\partial x}{\partial\theta} \\
    &= \frac{1}{\sin\theta}\left[(m^2-\nu^2(\cos^2\theta+1)-\nu)P_\nu^m(\cos\theta)+\nu(\nu+m)\cos\theta P_{\nu-1}^m(\cos\theta)+\nu(\nu-m+1)\cos\theta P_{\nu+1}^m(\cos\theta)\right]
  \end{align}
  For simplicity, define the function \(\Theta(\theta)\).
  \begin{align}
    &\Theta(\theta) = \frac{1}{\sin^2\theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial P_\nu^m}{\partial\theta}\right) \\
    &= \frac{1}{\sin\theta}\left[(m^2-\nu^2(\cos^2\theta+1)-\nu)P_\nu^m(\cos\theta)+\nu(\nu+m)\cos\theta P_{\nu-1}^m(\cos\theta)+\nu(\nu-m+1)\cos\theta P_{\nu+1}^m(\cos\theta)\right]
  \end{align}
  In this way, the second term of the Laplacian becomes
  \begin{equation}
    \frac{1}{r^2\sin\theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial B_n}{\partial\theta}\right) = e^{-z/2}L_k(z)\frac{\Theta(\theta)}{r^2}A_{\nu m}(\phi)
  \end{equation}

  The \(\phi\) term of the Laplacian is significantly simpler and can be calculated as follows.
  \begin{align}
    \parder{B_n}{\phi} &= e^{-\frac{z}{2}}L_k(z)P_\nu^m(\cos\theta)\parder{A_{\nu m}}{\phi} \\
    \pardder{B_n}{\phi} &= e^{-\frac{z}{2}}L_k(z)P_\nu^m(\cos\theta)\pardder{A_{\nu m}}{\phi}
  \end{align}
  Take the first and second derivatives of \(A_{\nu m}\).
  \begin{align}
    \parder{A_{\nu m}}{\phi} &= m \begin{cases}
                        K_{\nu |m|}\cos(|m|\phi) & m < 0 \\
                        0 & m = 0 \\
                        -K_{\nu m}\sin(m\phi) & m > 0
                      \end{cases} \\
    \pardder{A_{\nu m}}{\phi} &= -m^2 \begin{cases}
                        K_{\nu |m|}\sin(|m|\phi) & m < 0 \\
                        0 & m = 0 \\
                        K_{\nu m}\cos(m\phi) & m > 0
                      \end{cases} \\
  \end{align}
  This results in the convenient property
  \begin{equation}
    \pardder{A_{\nu m}}{\phi} = -m^2A_{\nu m}
  \end{equation}
  such that the last term in the Laplacian can be expressed as
  \begin{equation}
    \frac{1}{r^2\sin^2\theta}\pardder{B_n}{\phi} = -e^{-\frac{z}{2}}L_k(z)\frac{m^2}{r^2\sin^2\theta}P_\nu^m(\cos\theta)A_{\nu m}
  \end{equation}

  In total, the full Laplacian of the 3D basis function can be expressed as follows.
  \begin{multline}
    \nabla^2 B_n = \left(\frac{100}{R_E}\right)^2\frac{1}{r}\left[2\left(\frac{R_E}{100}\right)\frac{\partial Z}{\partial z} + r\frac{\partial^2 Z}{\partial z^2}\right]P_\nu^m(\cos\theta) A_{\nu m}(\phi) \\ + e^{-z/2}L_k(z)\frac{\Theta(\theta)}{r^2}A_{\nu m}(\phi) + -e^{-\frac{z}{2}}L_k(z)\frac{m^2}{r^2\sin^2\theta}P_\nu^m(\cos\theta)A_{\nu m}
  \end{multline}

  \subsection{Perpendicular Laplacian}
  The perpendicular Laplacian is defined by setting all radial derivatives in the full Laplacian to zero.
  \begin{equation}
    \nabla_\perp^2 f = \frac{1}{z^2 \sin\theta} \parder{}{\theta}\left(\sin\theta \parder{f}{\theta}\right) + \frac{1}{z^2 \sin^2\theta}\pardder{f}{\phi}
  \end{equation}
  Both terms have actually been calculated previously for the full Laplacian.
  \begin{align}
    \frac{1}{z^2\sin\theta}\parder{}{\theta}\left(\sin\theta\parder{B_n}{\theta}\right) &= \frac{e^{-\frac{z}{2}}}{z^2}L_k(z)\Theta(\theta)A_{\nu m}(\phi) \\
    % &\Theta(\theta) = \frac{1}{\sin\theta}\left[(m^2-\nu^2(\cos^2\theta+1)-\nu)P_\nu^m(\cos\theta)+\nu(\nu+m)\cos\theta P_{\nu-1}^m(\cos\theta)+\nu(\nu-m+1)\cos\theta P_{\nu+1}^m(\cos\theta)\right] \\
    \frac{1}{z^2\sin^2\theta}\pardder{B_n}{\phi} &= -\frac{m^2e^{-\frac{z}{2}}}{z^2\sin^2\theta}L_k(z)P_\nu^m(\cos\theta)A_{\nu m}(\phi)
  \end{align}
  Combining these terms yields the following perpendicular Laplacian.
  \begin{align}
    \nabla_\perp^2 B_n &= \frac{e^{-\frac{z}{2}}}{z^2}L_k(z)\Theta(\theta)A_{\nu m}(\phi)-\frac{m^2e^{-\frac{z}{2}}}{z^2\sin^2\theta}L_k(z)P_\nu^m(\cos\theta)A_{\nu m}(\phi) \\
    &= \frac{e^{-\frac{z}{2}}}{z^2}L_k(z)\left[\Theta(\theta)-\frac{m^2}{\sin^2\theta}P_\nu^m(\cos\theta)\right]A_{\nu m}(\phi)
  \end{align}
  Create a new function \(\Theta'_{\nu m}(\theta)\) to represent all \(\theta\) contributions to the perpendicular Laplacian.
  \begin{align}
    &\Theta'_{\nu m}(\theta) = \Theta - \frac{m^2}{\sin^2\theta}P_\nu^m(\cos\theta) \\
    &= \frac{1}{\sin^2\theta}\left[-\nu\left(\nu\cos^2\theta+\nu+1\right)P_\nu^m(\cos\theta)+\nu(\nu+m)\cos\theta P_{\nu-1}^m(\cos\theta)+\nu(\nu-m+1)\cos\theta P_{\nu+1}^m(\cos\theta)\right]
  \end{align}


  \bibliographystyle{apalike}
  \bibliography{bibliography}

\end{document}
